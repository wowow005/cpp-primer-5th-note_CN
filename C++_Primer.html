<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<title>C++ Primer Note</title>
<meta name="author" content="(Mushi)"/>
<style type="text/css">
.underline { text-decoration: underline; }
</style>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/reveal.js/dist/reveal.css"/>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/reveal.js/dist/theme/moon.css" id="theme"/>

<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
</head>
<body>
<div class="reveal">
<div class="slides">
<section id="sec-title-slide"><h1 class="title">C++ Primer Note</h1><h2 class="author">Mushi</h2><h2 class="date">2022-04-30 Sat 16:27</h2><p class="date">Created: 2022-05-02 Mon 15:57</p>
</section>
<section id="sec-table-of-contents"><div id="table-of-contents" role="doc-toc">
<h2>Table of Contents</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#/slide-org5ecdea9">1. 开始</a>
<ul>
<li><a href="#/slide-orga711a2f">1.1. 编写一个简单的 C++ 程序</a>
<ul>
<li><a href="#/slide-orgd27fdad">1.1.1. 编译, 运行程序</a></li>
</ul>
</li>
<li><a href="#/slide-org9f39ade">1.2. 初始输入输出</a>
<ul>
<li><a href="#/slide-org7eed2a2">1.2.1. 标准输入输出对象</a></li>
<li><a href="#/slide-orgbb99e6d">1.2.2. 一个使用 IO 库的程序</a></li>
<li><a href="#/slide-orgc926da3">1.2.3. 向流写入数据</a></li>
<li><a href="#/slide-org4162c43">1.2.4. 使用标准库中的名字</a></li>
<li><a href="#/slide-org693a762">1.2.5. 从流读取数据</a></li>
<li><a href="#/slide-org4e4cb43">1.2.6. 完成程序</a></li>
</ul>
</li>
<li><a href="#/slide-orgaa4f293">1.3. 注释简介</a>
<ul>
<li><a href="#/slide-org42d60ed">1.3.1. C++ 中的两种注释</a></li>
<li><a href="#/slide-org06201c1">1.3.2. 注释界定符不能嵌套</a></li>
</ul>
</li>
<li><a href="#/slide-orgc60c8ce">1.4. 控制流</a>
<ul>
<li><a href="#/slide-orge961b15">1.4.1. while 语句</a></li>
<li><a href="#/slide-org354af3c">1.4.2. for 语句</a></li>
<li><a href="#/slide-org2b85aa3">1.4.3. 读取数量不定的输入数据</a></li>
<li><a href="#/slide-org6c00df4">1.4.4. if 语句</a></li>
</ul>
</li>
<li><a href="#/slide-orgb83c2fd">1.5. 类简介</a>
<ul>
<li><a href="#/slide-org67764f2">1.5.1. Sales_item 类</a></li>
<li><a href="#/slide-orgc734f6e">1.5.2. 初始成员函数</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>
</section>


<p>
\mainmatter
</p>

<section>
<section id="slide-org5ecdea9">
<h2 id="org5ecdea9"><span class="section-number-2">1.</span> 开始</h2>
<div>
\begin{introduction}
  \item 一个简单的 C++ 程序
  \item 输入输出
  \item 注释简介
  \item 控制流
  \item 类简介
  \item 书店程序
\end{introduction}

</div>

</section>
<section id="slide-orga711a2f">
<h3 id="orga711a2f"><span class="section-number-3">1.1.</span> 编写一个简单的 C++ 程序</h3>
<p>
每个 C++ 程序都包含一个或多个 <b>函数</b> (function), 其中一个必须命名为 <code>main</code>. 操作系统
通过调用 <code>main</code> 来运行 C++ 程序.
</p>

<p>
\vspace*{1\baselineskip}
</p>

<p>
示例如下所示:
</p>

<div class="org-src-container">

<pre  class="src src-cpp"   ><code trim><span style="color: #6ae4b9;">int</span> <span style="color: #feacd0;">main</span><span style="color: #ffffff;">()</span> <span style="color: #ffffff;">{</span>
  <span style="color: #b6a0ff;">return</span> <span style="color: #00bcff;">0</span>;
<span style="color: #ffffff;">}</span>
</code></pre>
</div>

<p>
一个函数的定义包含四部分: <b>返回类型</b> (return type), <b>函数名</b> (function), 一个括
号包围的 <b>形参列表</b> (parameter list, 允许为空) 以及 <b>函数体</b> (function body)
</p>

<p>
<code>main</code> 函数的返回类型必须是 <code>int</code>, 即整数类型. <code>int</code> 类型是一种 <b>内置类型</b>
(built-in-type), 即语言自身定义的类型.
</p>

<p>
这个语句中唯一的一条语句是 <code>return</code>, 它结束函数的执行. 在本例中, <code>return</code> 还会向
调用者返回一个值. 当 <code>return</code> 语句包括一个值时, 次返回的类型必须与函数的返回类型
相容.
</p>

<p>
\vspace*{1\baselineskip}
</p>

<div>
\begin{note}
在 C/C++ 中, 新手常犯的错误就是忘记写分号. 代码写多了形成条件反射了就好了(当然有时候还是会漏掉 LOL).
\end{note}

</div>

<p>
\vspace*{1\baselineskip}
</p>

<p>
在大多数系统中, <code>main</code> 的返回值被用来指示状态. 返回值 <code>0</code> 表示成功. 非 <code>0</code> 返回
值由系统定义, 通常用来指出错误类型.
</p>

<p>
\vspace*{1\baselineskip}
</p>

<div>
\begin{definition}[类型]
类型是程序设计中最基本的概念之一, 在本书中我们会反复遇到他. 一种类型不仅定义了数据元素的内容, 还定义了这类数据上可以进行的运算.

程序所处理的数据都保存在变量中, 而每个变量都有自己的类型.
\end{definition}

</div>

</section>
<section id="slide-orgd27fdad">
<h4 id="orgd27fdad"><span class="section-number-4">1.1.1.</span> 编译, 运行程序</h4>
<p>
如何编译程序依赖于你使用的操作系统和编译器. 这里我不想展开讨论, 你可以通过搜索引
擎解决这些问题. 你的搜索关键词应该是 &ldquo;&lt;你的操作系统&gt; + 搭建 C++ 运行环境&rdquo;
</p>

<p>
尽管在生产环境中使用 <b>集成开发环境</b> (Integrated Developed Enveloped Environment,
IDE) 是高效的. 但我个人还是推荐你先借助命令行界面学习 C++ 本身, 一旦你掌握了语言,
IDE 再强大也只是一个工具而已.
</p>

<ol class="org-ol">
<li><a id="orgfddd3ed"></a>程序源文件<br />
<p>
大多数编译器都要求程序源码存储在一个或多个文件中. 程序文件通常被称为 <code>源文件</code>
(source file).
</p>

<p>
不同编译器使用不同的后缀命名方式, 最常见的包括 <code>.cc</code>, <code>.cxx</code>, <code>.cpp</code>, <code>.cp</code> 及 <code>.c</code>
</p>
</li>

<li><a id="org2893799"></a>从命令行运行编译器<br />
<p>
这里我简单演示一下命令行编译过程, 见下图:
</p>


<div id="org2e840d5" class="figure">
<p><img src="img/democc_演示.png" alt="democc_演示.png" />
</p>
</div>

<div>
\begin{note}
这里的 echo \$? 是一个 UNIX 命令, 它这里返回的就是最近的函数返回值. 在 Windows 系统中, 可以键入 echo \%ERRORLEVEL\% 查看
\end{note}

</div>
</li>
</ol>

</section>
<section id="slide-org9f39ade">
<h3 id="org9f39ade"><span class="section-number-3">1.2.</span> 初始输入输出</h3>
<p>
C++ 语言并未定义任何输入输出 (IO) 语句, 取而代之, 包含了一个全面的 <b>标准库</b>
(standard library) 来提供 IO 机制 (以及很多其他设施).
</p>

<p>
<b>iostream</b> 库包含两个基本类型 <b>istream</b> 和 <b>ostream</b>, 分别表示输入流和输出流. 一
个流就是一个字符序列. 术语 (stream) 想要表达的是, 随着时间的推移, 字符是顺序生
成或消耗的.
</p>

</section>
<section id="slide-org7eed2a2">
<h4 id="org7eed2a2"><span class="section-number-4">1.2.1.</span> 标准输入输出对象</h4>
<p>
标准库定义了 4 个 IO 对象, 见下表:
</p>

<table id="orge35728e" border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">对象名</th>
<th scope="col" class="org-left">作用</th>
<th scope="col" class="org-left">别称</th>
<th scope="col" class="org-left">所属类</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left"><code>cin</code></td>
<td class="org-left">处理输入</td>
<td class="org-left">标准输入 (standard input)</td>
<td class="org-left"><code>istream</code></td>
</tr>

<tr>
<td class="org-left"><code>cout</code></td>
<td class="org-left">处理输出</td>
<td class="org-left">标准输出 (standard output)</td>
<td class="org-left"><code>ostream</code></td>
</tr>

<tr>
<td class="org-left"><code>cerr</code></td>
<td class="org-left">输出警告和错误消息</td>
<td class="org-left">标准错误 (standard error)</td>
<td class="org-left"><code>ostream</code></td>
</tr>

<tr>
<td class="org-left"><code>clog</code></td>
<td class="org-left">输出程序运行时的一般性信息</td>
<td class="org-left">无</td>
<td class="org-left"><code>ostream</code></td>
</tr>
</tbody>
</table>

<p>
系统通常将程序所运行的窗口与这些对象关联起来. 因此, 当我们读取 <code>cin</code>, 数据将从程
序正在运行的窗口读入, 当我们向 <code>cout</code>, <code>cerr</code>, 和 <code>clog</code> 写入数据时, 将会写到同
一个窗口.
</p>

</section>
<section id="slide-orgbb99e6d">
<h4 id="orgbb99e6d"><span class="section-number-4">1.2.2.</span> 一个使用 IO 库的程序</h4>
<p>
在书店程序中, 我们需要将多条记录合并成单一的汇总表. 作为一个相关的, 但更简单的问
题, 我们先看一下如何将两个数相加. 通过使用 IO 库, 我们可以拓展 <code>main</code> 程序, 使之
能提示用户输入两个数, 然后输出它们的和:
</p>

<div class="org-src-container">

<pre  class="src src-cpp"   ><code trim><span style="color: #ff9077;">#include</span> <span style="color: #ffffff;">&lt;</span><span style="color: #79a8ff;">iostream</span><span style="color: #ffffff;">&gt;</span>

<span style="color: #6ae4b9;">int</span> <span style="color: #feacd0;">main</span><span style="color: #ffffff;">()</span> <span style="color: #ffffff;">{</span>
  <span style="color: #00bcff;">std</span>::cout &lt;&lt; <span style="color: #79a8ff;">"Enter two numbers:"</span> &lt;&lt; <span style="color: #00bcff;">std</span>::endl;
  <span style="color: #6ae4b9;">int</span> <span style="color: #00d3d0;">v1</span> = <span style="color: #00bcff;">0</span>, <span style="color: #00d3d0;">v2</span> = <span style="color: #00bcff;">0</span>;
  <span style="color: #00bcff;">std</span>::cin &gt;&gt; v1 &gt;&gt; v2;
  <span style="color: #00bcff;">std</span>::cout &lt;&lt; <span style="color: #79a8ff;">"The sum of "</span> &lt;&lt; v1 &lt;&lt; <span style="color: #79a8ff;">" and "</span> &lt;&lt; v2
            &lt;&lt; <span style="color: #79a8ff;">" is "</span> &lt;&lt; v1 + v2 &lt;&lt; <span style="color: #00bcff;">std</span>::endl;
  <span style="color: #b6a0ff;">return</span> <span style="color: #00bcff;">0</span>;
<span style="color: #ffffff;">}</span>
</code></pre>
</div>

<p>
尖括号中的 <code>iostream</code> 指出了一个 <code>头文件</code> (header). 我们一般一个程序的所有
<code>#include</code> 指令都放在源文件的开始位置.
</p>

</section>
<section id="slide-orgc926da3">
<h4 id="orgc926da3"><span class="section-number-4">1.2.3.</span> 向流写入数据</h4>
<p>
<code>main</code> 函数体的第一条语句执行了一个 <b>表达式</b> (expression). 在 C++ 中, 一个表达式
产生一个计算结果, 它由一个或多个运算对象和 (通常是) 一个运算符组成.
</p>

<p>
这条语句使用了 <b>输出运算符</b> (<code>&lt;&lt;</code>) 在标准输出上打印消息:
</p>

<div class="org-src-container">

<pre  class="src src-cpp"   ><code trim><span style="color: #00bcff;">std</span>::cout &lt;&lt; <span style="color: #79a8ff;">"Enter two numbers:"</span> &lt;&lt; <span style="color: #00bcff;">std</span>::endl;
</code></pre>
</div>

<p>
<code>&lt;&lt;</code> 运算符接受两个运算对象: 左侧的运算对象必须是一个 <code>ostream</code> 对象, 右侧的运算
对象是要打印的值. 此运算符将给定的值写到给定的 <code>ostream</code> 对象中. 计算结果是我们
写入给定值的那个 <code>ostream</code> 对象.
</p>

<p>
我们的输出语句使用了两次 &lt;&lt; 运算符. 我们的表达式等价于:
</p>

<div class="org-src-container">

<pre  class="src src-cpp"   ><code trim><span style="color: #ffffff;">(</span><span style="color: #00bcff;">std</span>::cout &lt;&lt; <span style="color: #79a8ff;">"Enter two numbers:"</span><span style="color: #ffffff;">)</span> &lt;&lt; <span style="color: #00bcff;">std</span>::endl;
</code></pre>
</div>

<p>
我们也可以把它变成两条语句, 效果是一样的:
</p>

<div class="org-src-container">

<pre  class="src src-cpp"   ><code trim><span style="color: #00bcff;">std</span>::cout &lt;&lt; <span style="color: #79a8ff;">"Enter two numbers:"</span>;
<span style="color: #00bcff;">std</span>::cout &lt;&lt; <span style="color: #00bcff;">std</span>::endl;
</code></pre>
</div>

<p>
第一个输出运算符给用户打印一条消息. 这个消息是一个 <b>字符串字面值常量</b> (string
literal).
</p>

<p>
第二个运算符打印 <code>endl</code>, 这是一个被称为 <b>操纵符</b> 的特殊值. 写入 <code>endl</code> 的效果是
结束当前行, 并将与设备关联的 <b>缓冲区</b> (buffer) 中的内容刷到设备中.
</p>

<p>
\vspace*{1\baselineskip}
</p>
<div>
\begin{note}
程序员常常在调试时添加打印语句. 这类语句应该保证 "一直" 刷新流. 否则, 如果程序崩溃, 输出可能还留在缓冲区中, 从而导致关于程序崩溃的错误推断.
\end{note}

</div>

</section>
<section id="slide-org4162c43">
<h4 id="org4162c43"><span class="section-number-4">1.2.4.</span> 使用标准库中的名字</h4>
<p>
前缀 <code>std::</code> 指出名字 <code>cout</code> 和 <code>endl</code> 是定义在名为 <b>std</b> 的命名空间 (namespace)
中的. 命名空间可以避免名字定义的冲突, 标准库定义的名字都在命名空间 <code>std</code> 中.
</p>

<p>
当我们使用标准库中的一个名字时, 必须显示说明我们想使用来自命名空间 <code>std</code> 中的名
字. 例如, 需要写出 <code>std::cout</code>, 通过使用 <b>作用域运算符</b> (<code>::</code>) 来指出我们想使用
定义在命名空间 <code>std</code> 中的名字 <code>cout</code>. 后面我们会介绍一种更简单的访问命名空间的方
法.
</p>

</section>
<section id="slide-org693a762">
<h4 id="org693a762"><span class="section-number-4">1.2.5.</span> 从流读取数据</h4>
<div class="org-src-container">

<pre  class="src src-cpp"   ><code trim><span style="color: #6ae4b9;">int</span> <span style="color: #00d3d0;">v1</span> = <span style="color: #00bcff;">0</span>, <span style="color: #00d3d0;">v2</span> = <span style="color: #00bcff;">0</span>;
</code></pre>
</div>

<p>
我们将这两个变量定义为 <code>int</code> 类型, <code>int</code> 是一种内置类型, 用来表示整数. 还将它们
<b>初始化</b> (initialize) 为 0. 初始化一个变量, 就是在变量创建的同时为它赋予一个值.
</p>

<p>
下一条语句是
</p>

<p>
std::cin &gt;&gt; v1 &gt;&gt; v2;
</p>

<p>
<b>输入运算符</b> (<code>&gt;&gt;</code>) 与输出运算符相似
</p>

</section>
<section id="slide-org4e4cb43">
<h4 id="org4e4cb43"><span class="section-number-4">1.2.6.</span> 完成程序</h4>
<p>
剩下的就是打印计算结果了:
</p>

<div class="org-src-container">

<pre  class="src src-cpp"   ><code trim><span style="color: #00bcff;">std</span>::cout &lt;&lt; <span style="color: #79a8ff;">"The sum of "</span> &lt;&lt; v1 &lt;&lt; <span style="color: #79a8ff;">" and "</span> &lt;&lt; v2
          &lt;&lt; <span style="color: #79a8ff;">" is "</span> &lt;&lt; v1 + v2 &lt;&lt; <span style="color: #00bcff;">std</span>::endl;
</code></pre>
</div>

<p>
可以发现, 这里的运算对象并不都是相同类型的值. 某些运算对象是字符串字面值常量, 某
些是 <code>int</code> 值.
</p>

<p>
标准库定义了不同版本的输入输出运算符, 来处理这些不同类型的运算对象.
</p>

</section>
<section id="slide-orgaa4f293">
<h3 id="orgaa4f293"><span class="section-number-3">1.3.</span> 注释简介</h3>
<p>
注释可以帮助人类读者理解程序.
</p>

</section>
<section id="slide-org42d60ed">
<h4 id="org42d60ed"><span class="section-number-4">1.3.1.</span> C++ 中的两种注释</h4>
<div class="org-src-container">

<pre  class="src src-cpp"   ><code trim><span style="color: #a8a8a8;">// </span><span style="color: #a8a8a8;">&#21452;&#26012;&#32447;&#27880;&#37322;&#24120;&#29992;&#20110;&#21322;&#34892;&#21644;&#21333;&#34892;&#38468;&#27880;.</span>

<span style="color: #a8a8a8;">/* </span><span style="color: #a8a8a8;">&#27880;&#37322;&#30028;&#23450;&#31526;</span>
<span style="color: #a8a8a8;">   &#36890;&#24120;&#29992;&#20110;</span>
<span style="color: #a8a8a8;">   &#22810;&#34892;&#27880;&#37322;</span>
<span style="color: #a8a8a8;">*/</span>
</code></pre>
</div>

</section>
<section id="slide-org06201c1">
<h4 id="org06201c1"><span class="section-number-4">1.3.2.</span> 注释界定符不能嵌套</h4>
<p>
界定注释符不能嵌套使用, 如果你这么做了, 编译器会产生错误.
</p>

<p>
最好的方式是用双斜线注释掉代码段的每一行.
</p>

<div class="org-src-container">

<pre  class="src src-cpp"   ><code trim><span style="color: #a8a8a8;">// </span><span style="color: #a8a8a8;">/*</span>
<span style="color: #a8a8a8;">// </span><span style="color: #a8a8a8;">* &#21333;&#34892;&#27880;&#37322;&#20013;&#30340;&#20219;&#20309;&#20869;&#23481;&#37117;&#20250;&#34987;&#24573;&#30053;</span>
<span style="color: #a8a8a8;">// </span><span style="color: #a8a8a8;">* &#21253;&#25324;&#23884;&#22871;&#30340;&#27880;&#37322;&#23545;&#20063;&#19968;&#26679;&#20250;&#34987;&#24573;&#30053;</span>
<span style="color: #a8a8a8;">// */</span>
</code></pre>
</div>

</section>
<section id="slide-orgc60c8ce">
<h3 id="orgc60c8ce"><span class="section-number-3">1.4.</span> 控制流</h3>
<p>
语句一般是顺序执行的, 但程序设计语言提供了多种不同的控制流语句, 允许我们写出更为
复杂的执行路径.
</p>

</section>
<section id="slide-orge961b15">
<h4 id="orge961b15"><span class="section-number-4">1.4.1.</span> while 语句</h4>
<p>
<b>while语句</b> 反复执行一段代码, 直到给定条件为假为止. 我们可以用 <code>while</code> 语句编写
一段程序, 求 1 到 10 这 10 个数的之和:
</p>

<div class="org-src-container">

<pre  class="src src-cpp"   ><code trim><span style="color: #ff9077;">#include</span> <span style="color: #ffffff;">&lt;</span><span style="color: #79a8ff;">iostream</span><span style="color: #ffffff;">&gt;</span>
<span style="color: #6ae4b9;">int</span> <span style="color: #feacd0;">main</span><span style="color: #ffffff;">()</span> <span style="color: #ffffff;">{</span>
  <span style="color: #6ae4b9;">int</span> <span style="color: #00d3d0;">sum</span> = <span style="color: #00bcff;">0</span>, <span style="color: #00d3d0;">val</span> = <span style="color: #00bcff;">1</span>;
  <span style="color: #a8a8a8;">// </span><span style="color: #a8a8a8;">&#21482;&#35201; val &#30340;&#20540;&#23567;&#20110;&#31561;&#20110; 10, while &#24490;&#29615;&#23601;&#20250;&#25345;&#32493;&#25191;&#34892;</span>
  <span style="color: #b6a0ff;">while</span> <span style="color: #ff62d4;">(</span>val &lt;= <span style="color: #00bcff;">10</span><span style="color: #ff62d4;">)</span> <span style="color: #ff62d4;">{</span>
    sum += val; <span style="color: #a8a8a8;">// </span><span style="color: #a8a8a8;">&#23558; sum + val &#36171;&#20104; sum</span>
    ++val;      <span style="color: #a8a8a8;">// </span><span style="color: #a8a8a8;">&#23558; val &#21152; 1</span>
  <span style="color: #ff62d4;">}</span>
  <span style="color: #00bcff;">std</span>::cout &lt;&lt; <span style="color: #79a8ff;">"sum of 1 to 10 inclusive is "</span>
            &lt;&lt; sum &lt;&lt; <span style="color: #00bcff;">std</span>::endl;
  <span style="color: #b6a0ff;">return</span> <span style="color: #00bcff;">0</span>;
<span style="color: #ffffff;">}</span>
</code></pre>
</div>

<p>
我们编译这个程序, 它会打印出:
</p>

<pre class="example">
sum of 1 to 10 inclusive is 55
</pre>


<p>
<code>while</code> 语句的形式为:
</p>

<div class="org-src-container">

<pre  class="src src-cpp"   ><code trim><span style="color: #b6a0ff;">while</span> <span style="color: #ffffff;">(</span>condition<span style="color: #ffffff;">)</span>
  statement
</code></pre>
</div>

<p>
<code>while</code> 语句的执行过程就是交替地监测 condition 条件和执行关联的语句 statement,
直至 consition 为假时停止. 所谓 <b>条件</b> (condition) 就是一个产生真或假的结果的表
达式.
</p>

<p>
条件中使用了 <b>小于等于运算符</b> (&lt;=) 运算符来比较 val 的当前值和 10.
</p>

<p>
循环体是由两条语句组成的语句块.
</p>

<div class="org-src-container">

<pre  class="src src-cpp"   ><code trim><span style="color: #ffffff;">{</span>
    sum += val; <span style="color: #a8a8a8;">// </span><span style="color: #a8a8a8;">&#23558; sum + val &#36171;&#20104; sum</span>
    ++val;      <span style="color: #a8a8a8;">// </span><span style="color: #a8a8a8;">&#23558; val &#21152; 1</span>
<span style="color: #ffffff;">}</span>
</code></pre>
</div>

<p>
所谓 <b>语句块</b> (block) 就是用花括号包围的零条或多条语句的序列. 语句块也是语句的一
种, 在任何要求使用语句的地方都可以使用语句块.
</p>

<p>
上面的语句块的第一条语句使用了 <b>复合赋值运算符</b> (+=). 此运算符将其右侧的运算对象
加到左侧运算对象中. 它本质上与一个加法结合一个 <b>赋值</b> (assignment) 是相同的.
</p>

<p>
第二条语句使用 <b>前缀递增运算符</b> (++). 递增运算符将运算对象的值增加 1. <code>++val</code> 等
价于 <code>val=val+1</code>.
</p>

</section>
<section id="slide-org354af3c">
<h4 id="org354af3c"><span class="section-number-4">1.4.2.</span> for 语句</h4>
<p>
在 <code>while</code> 语句中, 使用变量 <code>val</code> 来控制循环执行的次数. 在循环条件中监测 <code>val</code> 的
值, 在 <code>while</code> 循环体中将 <code>val</code> 递增.
</p>

<p>
这种在循环条件中检测变量, 在循环体中递增变量的模式使用非常频繁, 以至于 C++ 语言
专门定义了第二种循环语句, <b>for 语句</b>, 来简化复合这种模式的语句. 可以用 <code>for</code> 语
句来重写从 1 加到 10 的程序:
</p>

<div class="org-src-container">

<pre  class="src src-cpp"   ><code trim><span style="color: #ff9077;">#include</span> <span style="color: #ffffff;">&lt;</span><span style="color: #79a8ff;">iostream</span><span style="color: #ffffff;">&gt;</span>
<span style="color: #6ae4b9;">int</span> <span style="color: #feacd0;">main</span><span style="color: #ffffff;">()</span> <span style="color: #ffffff;">{</span>
  <span style="color: #6ae4b9;">int</span> <span style="color: #00d3d0;">sum</span> = <span style="color: #00bcff;">0</span>;
  <span style="color: #a8a8a8;">// </span><span style="color: #a8a8a8;">&#20174; 1 &#21152;&#21040; 10</span>
  <span style="color: #b6a0ff;">for</span> <span style="color: #ff62d4;">(</span><span style="color: #6ae4b9;">int</span> <span style="color: #00d3d0;">val</span> = <span style="color: #00bcff;">1</span>; val &lt;= <span style="color: #00bcff;">10</span>; ++val<span style="color: #ff62d4;">)</span> <span style="color: #ff62d4;">{</span>
    sum +=val;
  <span style="color: #ff62d4;">}</span>
  <span style="color: #00bcff;">std</span>::cout &lt;&lt; <span style="color: #79a8ff;">"Sum of 1 to 10 inclusive is "</span>
            &lt;&lt; sum &lt;&lt; <span style="color: #00bcff;">std</span>::endl;
  <span style="color: #b6a0ff;">return</span> <span style="color: #00bcff;">0</span>;
<span style="color: #ffffff;">}</span>
</code></pre>
</div>

<p>
每个 <code>for</code> 语句都包含两部分: 循环头和循环体. 循环头控制循环体的执行次数, 它由三
部分组成:
</p>

<ul>
<li>初始化语句 (init-statement)</li>
<li>循环条件 (condition)</li>
<li>表达式 (expression)</li>

</ul>

<p>
在本例中, 初始化语句为:
</p>

<div class="org-src-container">

<pre  class="src src-cpp"   ><code trim><span style="color: #6ae4b9;">int</span> <span style="color: #00d3d0;">val</span> = <span style="color: #00bcff;">1</span>
</code></pre>
</div>

<p>
它定义了一个名为 <code>val</code> 的 <code>int</code> 型对象, 并为其赋值为 1. 变量 <code>val</code> 仅在 <code>for</code> 循
环内部存在, 在循环结束之后是不能使用的. 循环条件:
</p>

<div class="org-src-container">

<pre  class="src src-cpp"   ><code trim>val &lt;= <span style="color: #00bcff;">10</span>
</code></pre>
</div>

<p>
循环体每次执行前都会先检查循环条件.
</p>

<p>
表达式在 <code>for</code> 循环体之后执行. 在本例中表达式:
</p>

<div class="org-src-container">

<pre  class="src src-cpp"   ><code trim>++val
</code></pre>
</div>

<p>
简要重述一下 <code>for</code> 循环的总体执行过程:
</p>

<ol>
<li>创建变量 <code>val</code>, 将其初始化为 1.</li>
<li>检测 <code>val</code> 是否小于等于 10. 若检测成功, 执行 <code>for</code> 循环体. 若失败, 退出循环,
继续执行 <code>for</code> 循环体之后的第一条语句.</li>
<li>将 <code>val</code> 的值增加 1.</li>
<li>重复第 2 步的条件检测, 只要条件为真就继续执行剩余步骤.</li>

</ol>

</section>
<section id="slide-org2b85aa3">
<h4 id="org2b85aa3"><span class="section-number-4">1.4.3.</span> 读取数量不定的输入数据</h4>
<p>
拓展上一个对 1 到 10 求和程序的一个自然的想法就是实现对用户输入的一组数求和. 在
这种情况下, 我们预先不知道要对多少个数求和, 这就需要不断读取数据直至没有新的输入
为止, 代码如下:
</p>

<div class="org-src-container">

<pre  class="src src-cpp"   ><code trim><span style="color: #ff9077;">#include</span> <span style="color: #ffffff;">&lt;</span><span style="color: #79a8ff;">iostream</span><span style="color: #ffffff;">&gt;</span>
<span style="color: #6ae4b9;">int</span> <span style="color: #feacd0;">main</span><span style="color: #ffffff;">()</span> <span style="color: #ffffff;">{</span>
  <span style="color: #6ae4b9;">int</span> <span style="color: #00d3d0;">sum</span> = <span style="color: #00bcff;">0</span>, <span style="color: #00d3d0;">value</span> = <span style="color: #00bcff;">0</span>;
  <span style="color: #a8a8a8;">// </span><span style="color: #a8a8a8;">&#35835;&#21462;&#25968;&#25454;&#30452;&#21040;&#36935;&#35265;&#25991;&#20214;&#23614;, &#35745;&#31639;&#25152;&#26377;&#35835;&#20837;&#30340;&#20540;&#30340;&#21644;</span>
  <span style="color: #b6a0ff;">while</span> <span style="color: #ff62d4;">(</span><span style="color: #00bcff;">std</span>:: cin &gt;&gt; value<span style="color: #ff62d4;">)</span>
    sum += value;
  <span style="color: #00bcff;">std</span>::cout &lt;&lt; <span style="color: #79a8ff;">"Sum is: "</span> &lt;&lt; sum &lt;&lt; <span style="color: #00bcff;">std</span>::endl;
  <span style="color: #b6a0ff;">return</span> <span style="color: #00bcff;">0</span>;
<span style="color: #ffffff;">}</span>
</code></pre>
</div>

<p>
如果我们输入:
</p>

<pre  class="example" >
3 4 5 6
</pre>

<p>
则程序会输出:
</p>

<pre  class="example" >
Sum is: 18
</pre>
<p>
这个程序使用了 <code>istream</code> 对象作为条件, 其效果是检测流的状态. 如果流是有效的, 即
流未遇到错误, 那么检测成功. 当遇到 <b>文件结束符</b> (end-of-file), 或遇到一个无效输
入时 (例如读入的值不是一个整数), <code>istream</code> 的对象的状态就会变为无效. 处于无效状
态的 <code>istream</code> 对象会使条件变为假.
</p>

<p>
\vspace*{1\baselineskip}
</p>
<div>
\begin{note}[从键盘输入文件结束符]

如何指出文件结束, 不同操作系统是不同的.

在 Windows 系统中, 输入文件结束符的方法是敲 Ctrl+Z.

在 UNIX 系统中, 包括 Mac OS X 系统中, 是用 Ctrl+D.
\end{note}

</div>


<p>
\vspace*{1\baselineskip}
</p>
<div>
\begin{note}[常见错误]

下面列出一些编译器可以检查出的错误:

1. 语法错误(syntax error): 犯了 C++ 语言文法上的错误

2. 类型错误 (type error): C++ 中每个数据项都有其类型.

3. 声明错误 (declaration error): 每个名字都要先声明, 后使用.
\end{note}

</div>

</section>
<section id="slide-org6c00df4">
<h4 id="org6c00df4"><span class="section-number-4">1.4.4.</span> if 语句</h4>
<p>
与大多数语言一样, C++ 也提供了 <b>if 语句</b> 来支持条件执行. 我们可以用 <code>if</code> 语句写一
个程序, 来统计在输入中, 每个值连续出现了多少次:
</p>

<div class="org-src-container">

<pre  class="src src-cpp"   ><code trim><span style="color: #ff9077;">#include</span> <span style="color: #ffffff;">&lt;</span><span style="color: #79a8ff;">iostream</span><span style="color: #ffffff;">&gt;</span>

<span style="color: #6ae4b9;">int</span> <span style="color: #feacd0;">main</span><span style="color: #ffffff;">()</span> <span style="color: #ffffff;">{</span>
  <span style="color: #a8a8a8;">// </span><span style="color: #a8a8a8;">currVal &#26159;&#25105;&#20204;&#27491;&#22312;&#32479;&#35745;&#30340;&#25968;; &#25105;&#20204;&#23558;&#35835;&#20837;&#30340;&#26032;&#20540;&#23384;&#20837; val</span>
  <span style="color: #6ae4b9;">int</span> <span style="color: #00d3d0;">currVal</span> = <span style="color: #00bcff;">0</span>, <span style="color: #00d3d0;">val</span> = <span style="color: #00bcff;">0</span>;
  <span style="color: #a8a8a8;">// </span><span style="color: #a8a8a8;">&#35835;&#21462;&#19968;&#20010;&#26032;&#25968;, &#24182;&#30830;&#20445;&#30830;&#23454;&#26377;&#25968;&#25454;&#21487;&#20197;&#22788;&#29702;</span>
  <span style="color: #b6a0ff;">if</span> <span style="color: #ff62d4;">(</span><span style="color: #00bcff;">std</span>::cin &gt;&gt; currVal<span style="color: #ff62d4;">)</span> <span style="color: #ff62d4;">{</span>
    <span style="color: #6ae4b9;">int</span> <span style="color: #00d3d0;">cnt</span> = <span style="color: #00bcff;">1</span>;                <span style="color: #a8a8a8;">// </span><span style="color: #a8a8a8;">&#20445;&#23384;&#25105;&#20204;&#27491;&#22312;&#22788;&#29702;&#30340;&#24403;&#21069;&#20540;&#30340;&#20010;&#25968;</span>
    <span style="color: #b6a0ff;">while</span> <span style="color: #3fdfd0;">(</span><span style="color: #00bcff;">std</span>::cin &gt;&gt; val<span style="color: #3fdfd0;">)</span> <span style="color: #3fdfd0;">{</span> <span style="color: #a8a8a8;">// </span><span style="color: #a8a8a8;">&#35835;&#21462;&#21097;&#20313;&#30340;&#25968;</span>
      <span style="color: #b6a0ff;">if</span> <span style="color: #fba849;">(</span>val == currVal<span style="color: #fba849;">)</span>     <span style="color: #a8a8a8;">// </span><span style="color: #a8a8a8;">&#22914;&#26524;&#20540;&#30456;&#21516;</span>
        ++cnt;                <span style="color: #a8a8a8;">// </span><span style="color: #a8a8a8;">&#23558; cnt &#21152; 1</span>
      <span style="color: #b6a0ff;">else</span> <span style="color: #fba849;">{</span>                  <span style="color: #a8a8a8;">// </span><span style="color: #a8a8a8;">&#21542;&#21017;, &#25171;&#21360;&#21069;&#19968;&#20010;&#25968;&#30340;&#20540;</span>
        <span style="color: #00bcff;">std</span>::cout &lt;&lt; currVal &lt;&lt; <span style="color: #79a8ff;">" occurs "</span>
                  &lt;&lt; cnt &lt;&lt; <span style="color: #79a8ff;">" times"</span> &lt;&lt; <span style="color: #00bcff;">std</span>::endl;
        currVal = val;        <span style="color: #a8a8a8;">// </span><span style="color: #a8a8a8;">&#35760;&#20303;&#26032;&#20540;</span>
        cnt = <span style="color: #00bcff;">1</span>;              <span style="color: #a8a8a8;">// </span><span style="color: #a8a8a8;">&#37325;&#32622;&#35745;&#25968;&#22120;</span>
      <span style="color: #fba849;">}</span>
    <span style="color: #3fdfd0;">}</span>
  <span style="color: #ff62d4;">}</span>
<span style="color: #ffffff;">}</span>
</code></pre>
</div>

<p>
如果我们输入如下内容:
</p>

<pre  class="example" >
42 42 42 42 42 55 55 62 100 100 100
</pre>

<p>
则应该输出:
</p>

<pre  class="example" >
42 occurs 5 times
55 occurs 2 times
62 occurs 1 times
</pre>

<p>
第二条 <code>if</code> 语句使用了 <b>相等运算符</b> (<code>==</code>) 来检测 <code>val</code> 是否等于 <code>currVal</code>
</p>

<p>
\vspace*{1\baselineskip}
</p>
<div>
\begin{note}
C++ 用 = 进行赋值, 用 == 作为相等运算符.
\end{note}

</div>


<p>
\vspace*{1\baselineskip}
</p>
<div>
\begin{definition}[C++ 程序的缩进和格式]
C++ 很大程度上是格式自由的, 不存在正确的格式, 但是你最好应该保持一致的风格.
\end{definition}

</div>

</section>
<section id="slide-orgb83c2fd">
<h3 id="orgb83c2fd"><span class="section-number-3">1.5.</span> 类简介</h3>
<p>
在解决书店程序之前, 我们还需要了解的唯一的一个 C++ 特性就是如何定义一个 <b>数据结
构</b> (data structure) 来表示销售数据. 在 C++ 中, 我们通过定义一个 <b>类</b> (class) 来
定义自己的数据结构.
</p>

<p>
一个类定义了一个类型, 以及与其相关联的一组操作.
</p>

<p>
类机制是 C++ 最重要的特性之一. C++ 最初的设计焦点就是能定义使用上像内置类型一样
自然的 <b>类类型</b> (type).
</p>

<p>
在这节中, 我们只介绍简单的使用类, 而不关心它的实现.
</p>

</section>
<section id="slide-org67764f2">
<h4 id="org67764f2"><span class="section-number-4">1.5.1.</span> Sales_item 类</h4>
<p>
<code>Sales_item</code> 类的作用是表示一本书的总销售额, 售出册数和平均售价.
</p>

<p>
每个类实际上都定义了一个新的类型, 其类型名就是类名. 因此, 我们的 <code>Sales_item</code> 定
义了一个名为 <code>Sales_item</code> 的类型. 与内置类型一样, 我们可以定义类类型的变量.
</p>

<p>
当我们写下:
</p>

<pre  class="example" >
Sales_item item;
</pre>

<p>
表示的是 <code>item</code> 是一个 <code>Sales_item</code> 类型的对象. 我们通常将 &ldquo;一个 <code>Sales_item</code> 类
型的对象&rdquo; 简单说成 &ldquo;一个 <code>Sales_item</code> 对象&rdquo;, 或更简单 &ldquo;一个 <code>Sales_item</code>&rdquo;
</p>

<p>
对于 <code>Sales_item</code> 这个类, 除了可以定义 <code>Sales_item</code> 的对象外, 还可以:
</p>

<ul>
<li>调用一个名为 <code>isbn</code> 的函数从一个 <code>Sales_item</code> 对象中提取 <code>ISBN</code> 号.</li>
<li>用输入运算符 (&gt;&gt;) 和输出运算符 (&lt;&lt;) 读, 写 <code>Sales_item</code> 对象.</li>
<li>用加法运算符 (+) 将两个 <code>Sales_item</code> 对象相加. 两个对象必须是同一本书 (相同的
<code>ISBN</code>). 运算结果是一个新的 <code>Sales_item</code> 对象, <code>ISBN</code> 不变, 总销售额和售出册数
则是两个运算对象的对应值之和.</li>
<li>使用复合赋值运算符 (+=) 将一个 <code>Sales_item</code> 对象加到另一个对象上.</li>

</ul>

<p>
\vspace*{1\baselineskip}
</p>
<div>
\begin{definition}[类定义了行为]
你要记住的是, 类 Sales\_item 的作者定义了类对象可以执行的所有动作.

一般而言, 类的作者决定了类对象上可以使用的所有操作.
\end{definition}

</div>

<ol class="org-ol">
<li><a id="org6e444e9"></a>读写 Sales_item<br />
<p>
如下面这个程序, 从标准输入读入数据, 存入一个 <code>Sales_item</code> 对象中, 然后将
<code>Sales_item</code> 的内容写回到标准输出:
</p>

<div class="org-src-container">

<pre  class="src src-cpp"   ><code trim><span style="color: #ff9077;">#include</span> <span style="color: #ffffff;">&lt;</span><span style="color: #79a8ff;">iostream</span><span style="color: #ffffff;">&gt;</span>
<span style="color: #ff9077;">#include</span> <span style="color: #79a8ff;">"Sales_item.h"</span>

<span style="color: #6ae4b9;">int</span> <span style="color: #feacd0;">main</span><span style="color: #ffffff;">()</span> <span style="color: #ffffff;">{</span>
  <span style="color: #6ae4b9;">Sales_item</span> <span style="color: #00d3d0;">book</span>;
  <span style="color: #a8a8a8;">// </span><span style="color: #a8a8a8;">&#35835;&#20837; ISBN &#21495;, &#21806;&#20986;&#30340;&#20876;&#25968;&#20197;&#21450;&#38144;&#21806;&#20215;&#26684;</span>
  <span style="color: #00bcff;">std</span>::cin &gt;&gt; book;
  <span style="color: #a8a8a8;">// </span><span style="color: #a8a8a8;">&#20889;&#20837; ISBN, &#21806;&#20986;&#30340;&#20876;&#25968;, &#24635;&#38144;&#21806;&#25968;&#21644;&#24179;&#22343;&#20215;&#26684;</span>
  <span style="color: #00bcff;">std</span>::count &lt;&lt; book &lt;&lt; <span style="color: #00bcff;">std</span>::endl;
  <span style="color: #b6a0ff;">return</span> <span style="color: #00bcff;">0</span>;
<span style="color: #ffffff;">}</span>
</code></pre>
</div>

<p>
如果输入:
</p>

<pre  class="example" >
0-201-70353-X 4 24.99
</pre>

<p>
则输出:
</p>
<pre  class="example" >
0-201-70353-X 4 99.96 24.99
</pre>

<p>
此程序以两个 <code>#include</code> 指令开始, 其中一个使用了新的形式. 包含来自标准库的头文件,
我们用 (&lt; &gt;) 包围头文件名. 对于不属于标准库的头文件, 则使用 (&ldquo;&rdquo;) 包围.
</p>

<p>
\vspace*{1\baselineskip}
</p>
<div>
\begin{note}[使用文件重定向]

反复从键盘敲入那些销售记录是乏味的. 大多数操作系统支持文件重定向.

$ addItems <infile >outfile

这样就可以从一个名为 infile 的文件中读取销售记录, 并将结果输出到一个名为 outfile 的文件.
\end{note}

</div>
</li>
</ol>

</section>
<section id="slide-orgc734f6e">
<h4 id="orgc734f6e"><span class="section-number-4">1.5.2.</span> 初始成员函数</h4>
<p>
将两个 <code>Sales_item</code> 对象相加的程序首先应该检查两个对象是否具有相同的 <code>ISBN</code>, 示
例如下:
</p>

<div class="org-src-container">

<pre  class="src src-cpp"   ><code trim><span style="color: #ff9077;">#include</span> <span style="color: #ffffff;">&lt;</span><span style="color: #79a8ff;">iostream</span><span style="color: #ffffff;">&gt;</span>
<span style="color: #ff9077;">#include</span> <span style="color: #79a8ff;">"Sales_item.h"</span>

<span style="color: #6ae4b9;">int</span> <span style="color: #feacd0;">main</span> <span style="color: #ffffff;">()</span>
<span style="color: #ffffff;">{</span>
  <span style="color: #6ae4b9;">Sales_item</span> <span style="color: #00d3d0;">item1</span>, <span style="color: #00d3d0;">item2</span>;
  <span style="color: #00bcff;">std</span>::cin &gt;&gt; item1 &gt;&gt; item2;
  <span style="color: #a8a8a8;">// </span><span style="color: #a8a8a8;">&#39318;&#20808;&#26816;&#26597; item1 &#21644; item2 &#26159;&#21542;&#34920;&#31034;&#30456;&#21516;&#30340;&#20070;</span>
  <span style="color: #b6a0ff;">if</span> <span style="color: #ff62d4;">(</span>item1.isbn<span style="color: #3fdfd0;">()</span> == item2.isbn<span style="color: #3fdfd0;">()</span><span style="color: #ff62d4;">)</span> <span style="color: #ff62d4;">{</span>
    <span style="color: #00bcff;">std</span>::cout &lt;&lt; item1 + item2 &lt;&lt; <span style="color: #00bcff;">std</span>::endl;
    <span style="color: #b6a0ff;">return</span> <span style="color: #00bcff;">0</span>;    <span style="color: #a8a8a8;">// </span><span style="color: #a8a8a8;">&#34920;&#31034;&#25104;&#21151;</span>
  <span style="color: #ff62d4;">}</span> <span style="color: #b6a0ff;">else</span> <span style="color: #ff62d4;">{</span>
    <span style="color: #00bcff;">std</span>::cerr &lt;&lt; <span style="color: #79a8ff;">"Data must refer to same ISBN"</span>
              &lt;&lt; <span style="color: #00bcff;">std</span>::endl;
    <span style="color: #b6a0ff;">return</span> -<span style="color: #00bcff;">1</span>;   <span style="color: #a8a8a8;">// </span><span style="color: #a8a8a8;">&#34920;&#31034;&#22833;&#36133;</span>
  <span style="color: #ff62d4;">}</span>
<span style="color: #ffffff;">}</span>
</code></pre>
</div>

<ol class="org-ol">
<li><a id="orgecf24af"></a>什么是成员函数<br />
<p>
上面例子中的 <code>if</code> 语句的检测条件
</p>

<pre  class="example" >
item1.isbn() == item2.isbn()
</pre>

<p>
调用名为 <code>isbn</code> 的 <b>成员函数</b> (member function). 成员函数时定义为类的一部分的函数,
有时也称为 <b>方法</b> (method).
</p>

<p>
我们使用 <b>点运算符</b> (.) 来表达我们需要 &ldquo;名为 <code>item1</code> 的对象的 <code>isbn</code> 成员&rdquo;. 点运
算符只能用于类类型的对象.
</p>

<p>
我们使用 <b>调用运算符</b> (()) 来调用一个函数. 圆括号里面放置 <b>实参</b> (argument) 列表
(可能为空). 成员函数 <code>isbn</code> 不接受任何参数.
</p>

<p>
这个函数返回的是保存在 <code>item1</code> 中的 <code>ISBN</code> 书号.
</p>
</li>
</ol>
</section>
</section>
</div>
</div>
<script src="https://cdn.jsdelivr.net/npm/reveal.js/dist/reveal.js"></script>
<script src="https://cdn.jsdelivr.net/npm/reveal.js/plugin/markdown/markdown.js"></script>
<script src="https://cdn.jsdelivr.net/npm/reveal.js/plugin/zoom/zoom.js"></script>
<script src="https://cdn.jsdelivr.net/npm/reveal.js/plugin/notes/notes.js"></script>


<script>
// Full list of configuration options available here:
// https://github.com/hakimel/reveal.js#configuration
Reveal.initialize({
plugins: [RevealMarkdown, RevealZoom, RevealNotes]
});

</script>
</body>
</html>
