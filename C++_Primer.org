:REVEAL_PROPERTIES:
#+REVEAL_ROOT: https://cdn.jsdelivr.net/npm/reveal.js
#+REVEAL_REVEAL_JS_VERSION: 4
:END:


#+AUTHOR: Mushi
#+DATE: [2022-04-30 Sat 16:27]
#+EMAIL: goodhelper005@gmail.com
#+LATEX_COMPILER: xelatex
#+LATEX_HEADER: \usepackage{xeCJK}
#+LATEX_HEADER: \setCJKmainfont{LXGW WenKai}
#+LATEX_HEADER: \documentclass[pad]{elegantbook}
#+LATEX_HEADER: \documentclass[hang]{elegantbook}
#+LATEX_CLASS: elegantbook
#+OPTIONS: prop:t
#+TITLE: C++ Primer Note


\mainmatter

* 开始

\begin{introduction}
  \item 一个简单的 C++ 程序
  \item 输入输出
  \item 注释简介
  \item 控制流
  \item 类简介
  \item 书店程序
\end{introduction}

** 编写一个简单的 C++ 程序

每个 C++ 程序都包含一个或多个 *函数* (function), 其中一个必须命名为 =main=. 操作系统
通过调用 =main= 来运行 C++ 程序.

\vspace*{1\baselineskip}

示例如下所示:

#+begin_src cpp
int main() {
  return 0;
}
#+end_src

一个函数的定义包含四部分: *返回类型* (return type), *函数名* (function), 一个括
号包围的 *形参列表* (parameter list, 允许为空) 以及 *函数体* (function body)

=main= 函数的返回类型必须是 =int=, 即整数类型. =int= 类型是一种 *内置类型*
(built-in-type), 即语言自身定义的类型.

这个语句中唯一的一条语句是 =return=, 它结束函数的执行. 在本例中, =return= 还会向
调用者返回一个值. 当 =return= 语句包括一个值时, 次返回的类型必须与函数的返回类型
相容.

\vspace*{1\baselineskip}

\begin{note}
在 C/C++ 中, 新手常犯的错误就是忘记写分号. 代码写多了形成条件反射了就好了(当然有时候还是会漏掉 LOL).
\end{note}

\vspace*{1\baselineskip}

在大多数系统中, =main= 的返回值被用来指示状态. 返回值 =0= 表示成功. 非 =0= 返回
值由系统定义, 通常用来指出错误类型.

\vspace*{1\baselineskip}

\begin{definition}[类型]
类型是程序设计中最基本的概念之一, 在本书中我们会反复遇到他. 一种类型不仅定义了数据元素的内容, 还定义了这类数据上可以进行的运算.

程序所处理的数据都保存在变量中, 而每个变量都有自己的类型.
\end{definition}

*** 编译, 运行程序

如何编译程序依赖于你使用的操作系统和编译器. 这里我不想展开讨论, 你可以通过搜索引
擎解决这些问题. 你的搜索关键词应该是 "<你的操作系统> + 搭建 C++ 运行环境"

尽管在生产环境中使用 *集成开发环境* (Integrated Developed Enveloped Environment,
IDE) 是高效的. 但我个人还是推荐你先借助命令行界面学习 C++ 本身, 一旦你掌握了语言,
IDE 再强大也只是一个工具而已.

**** 程序源文件

大多数编译器都要求程序源码存储在一个或多个文件中. 程序文件通常被称为 =源文件=
(source file).

不同编译器使用不同的后缀命名方式, 最常见的包括 =.cc=, =.cxx=, =.cpp=, =.cp= 及 =.c=

**** 从命令行运行编译器

这里我简单演示一下命令行编译过程, 见下图:

#+ATTR_LATEX: :width 1.0\textwidth
[[file:img/democc_演示.png]]

\begin{note}
这里的 echo \$? 是一个 UNIX 命令, 它这里返回的就是最近的函数返回值. 在 Windows 系统中, 可以键入 echo \%ERRORLEVEL\% 查看
\end{note}

** 初始输入输出

C++ 语言并未定义任何输入输出 (IO) 语句, 取而代之, 包含了一个全面的 *标准库*
(standard library) 来提供 IO 机制 (以及很多其他设施).

*iostream* 库包含两个基本类型 *istream* 和 *ostream*, 分别表示输入流和输出流. 一
个流就是一个字符序列. 术语 (stream) 想要表达的是, 随着时间的推移, 字符是顺序生
成或消耗的.

*** 标准输入输出对象

标准库定义了 4 个 IO 对象, 见下表:

#+NAME: 4 个 IO 对象
| 对象名 | 作用                       | 别称                       | 所属类    |
|--------+----------------------------+----------------------------+-----------|
| =cin=  | 处理输入                   | 标准输入 (standard input)  | =istream= |
| =cout= | 处理输出                   | 标准输出 (standard output) | =ostream= |
| =cerr= | 输出警告和错误消息         | 标准错误 (standard error)  | =ostream= |
| =clog= | 输出程序运行时的一般性信息 | 无                         | =ostream= |

系统通常将程序所运行的窗口与这些对象关联起来. 因此, 当我们读取 =cin=, 数据将从程
序正在运行的窗口读入, 当我们向 =cout=, =cerr=, 和 =clog= 写入数据时, 将会写到同
一个窗口.

*** 一个使用 IO 库的程序

在书店程序中, 我们需要将多条记录合并成单一的汇总表. 作为一个相关的, 但更简单的问
题, 我们先看一下如何将两个数相加. 通过使用 IO 库, 我们可以拓展 =main= 程序, 使之
能提示用户输入两个数, 然后输出它们的和:

#+begin_src cpp
#include <iostream>

int main() {
  std::cout << "Enter two numbers:" << std::endl;
  int v1 = 0, v2 = 0;
  std::cin >> v1 >> v2;
  std::cout << "The sum of " << v1 << " and " << v2
            << " is " << v1 + v2 << std::endl;
  return 0;
}
#+end_src

尖括号中的 =iostream= 指出了一个 =头文件= (header). 我们一般一个程序的所有
=#include= 指令都放在源文件的开始位置.

*** 向流写入数据

=main= 函数体的第一条语句执行了一个 *表达式* (expression). 在 C++ 中, 一个表达式
产生一个计算结果, 它由一个或多个运算对象和 (通常是) 一个运算符组成.

这条语句使用了 *输出运算符* (=<<=) 在标准输出上打印消息:

#+begin_src cpp
std::cout << "Enter two numbers:" << std::endl;
#+end_src

=<<= 运算符接受两个运算对象: 左侧的运算对象必须是一个 =ostream= 对象, 右侧的运算
对象是要打印的值. 此运算符将给定的值写到给定的 =ostream= 对象中. 计算结果是我们
写入给定值的那个 =ostream= 对象.

我们的输出语句使用了两次 << 运算符. 我们的表达式等价于:

#+begin_src cpp
(std::cout << "Enter two numbers:") << std::endl;
#+end_src

我们也可以把它变成两条语句, 效果是一样的:

#+begin_src cpp
std::cout << "Enter two numbers:";
std::cout << std::endl;
#+end_src

第一个输出运算符给用户打印一条消息. 这个消息是一个 *字符串字面值常量* (string
literal).

第二个运算符打印 =endl=, 这是一个被称为 *操纵符* 的特殊值. 写入 =endl= 的效果是
结束当前行, 并将与设备关联的 *缓冲区* (buffer) 中的内容刷到设备中.

\vspace*{1\baselineskip}
\begin{note}
程序员常常在调试时添加打印语句. 这类语句应该保证 "一直" 刷新流. 否则, 如果程序崩溃, 输出可能还留在缓冲区中, 从而导致关于程序崩溃的错误推断.
\end{note}

*** 使用标准库中的名字

前缀 =std::= 指出名字 =cout= 和 =endl= 是定义在名为 *std* 的命名空间 (namespace)
中的. 命名空间可以避免名字定义的冲突, 标准库定义的名字都在命名空间 =std= 中.

当我们使用标准库中的一个名字时, 必须显示说明我们想使用来自命名空间 =std= 中的名
字. 例如, 需要写出 =std::cout=, 通过使用 *作用域运算符* (=::=) 来指出我们想使用
定义在命名空间 =std= 中的名字 =cout=. 后面我们会介绍一种更简单的访问命名空间的方
法.

*** 从流读取数据

#+begin_src cpp
int v1 = 0, v2 = 0;
#+end_src

我们将这两个变量定义为 =int= 类型, =int= 是一种内置类型, 用来表示整数. 还将它们
*初始化* (initialize) 为 0. 初始化一个变量, 就是在变量创建的同时为它赋予一个值.

下一条语句是

std::cin >> v1 >> v2;

*输入运算符* (=>>=) 与输出运算符相似

*** 完成程序

剩下的就是打印计算结果了:

#+begin_src cpp
std::cout << "The sum of " << v1 << " and " << v2
          << " is " << v1 + v2 << std::endl;
#+end_src

可以发现, 这里的运算对象并不都是相同类型的值. 某些运算对象是字符串字面值常量, 某
些是 =int= 值.

标准库定义了不同版本的输入输出运算符, 来处理这些不同类型的运算对象.

** 注释简介

注释可以帮助人类读者理解程序.

*** C++ 中的两种注释

#+begin_src cpp
// 双斜线注释常用于半行和单行附注.

/* 注释界定符
   通常用于
   多行注释
,*/
#+end_src

*** 注释界定符不能嵌套

界定注释符不能嵌套使用, 如果你这么做了, 编译器会产生错误.

最好的方式是用双斜线注释掉代码段的每一行.

#+begin_src cpp
// /*
// * 单行注释中的任何内容都会被忽略
// * 包括嵌套的注释对也一样会被忽略
// */
#+end_src

** 控制流

语句一般是顺序执行的, 但程序设计语言提供了多种不同的控制流语句, 允许我们写出更为
复杂的执行路径.

*** while 语句

*while语句* 反复执行一段代码, 直到给定条件为假为止. 我们可以用 =while= 语句编写
一段程序, 求 1 到 10 这 10 个数的之和:

#+begin_src cpp
#include <iostream>
int main() {
  int sum = 0, val = 1;
  // 只要 val 的值小于等于 10, while 循环就会持续执行
  while (val <= 10) {
    sum += val; // 将 sum + val 赋予 sum
    ++val;      // 将 val 加 1
  }
  std::cout << "sum of 1 to 10 inclusive is "
            << sum << std::endl;
  return 0;
}
#+end_src

我们编译这个程序, 它会打印出:

#+RESULTS:
: sum of 1 to 10 inclusive is 55

=while= 语句的形式为:

#+begin_src cpp
while (condition)
  statement
#+end_src

=while= 语句的执行过程就是交替地监测 condition 条件和执行关联的语句 statement,
直至 consition 为假时停止. 所谓 *条件* (condition) 就是一个产生真或假的结果的表
达式.

条件中使用了 *小于等于运算符* (<=) 运算符来比较 val 的当前值和 10.

循环体是由两条语句组成的语句块.

#+begin_src cpp
{
    sum += val; // 将 sum + val 赋予 sum
    ++val;      // 将 val 加 1
}
#+end_src

所谓 *语句块* (block) 就是用花括号包围的零条或多条语句的序列. 语句块也是语句的一
种, 在任何要求使用语句的地方都可以使用语句块.

上面的语句块的第一条语句使用了 *复合赋值运算符* (+=). 此运算符将其右侧的运算对象
加到左侧运算对象中. 它本质上与一个加法结合一个 *赋值* (assignment) 是相同的.

第二条语句使用 *前缀递增运算符* (++). 递增运算符将运算对象的值增加 1. =++val= 等
价于 =val=val+1=.

*** for 语句

在 =while= 语句中, 使用变量 =val= 来控制循环执行的次数. 在循环条件中监测 =val= 的
值, 在 =while= 循环体中将 =val= 递增.

这种在循环条件中检测变量, 在循环体中递增变量的模式使用非常频繁, 以至于 C++ 语言
专门定义了第二种循环语句, *for 语句*, 来简化复合这种模式的语句. 可以用 =for= 语
句来重写从 1 加到 10 的程序:

#+begin_src cpp
#include <iostream>
int main() {
  int sum = 0;
  // 从 1 加到 10
  for (int val = 1; val <= 10; ++val) {
    sum +=val;
  }
  std::cout << "Sum of 1 to 10 inclusive is "
            << sum << std::endl;
  return 0;
}
#+end_src

每个 =for= 语句都包含两部分: 循环头和循环体. 循环头控制循环体的执行次数, 它由三
部分组成:

+ 初始化语句 (init-statement)
+ 循环条件 (condition)
+ 表达式 (expression)

在本例中, 初始化语句为:

#+begin_src cpp
int val = 1
#+end_src

它定义了一个名为 =val= 的 =int= 型对象, 并为其赋值为 1. 变量 =val= 仅在 =for= 循
环内部存在, 在循环结束之后是不能使用的. 循环条件:

#+begin_src cpp
val <= 10
#+end_src

循环体每次执行前都会先检查循环条件.

表达式在 =for= 循环体之后执行. 在本例中表达式:

#+begin_src cpp
++val
#+end_src

简要重述一下 =for= 循环的总体执行过程:

1. 创建变量 =val=, 将其初始化为 1.
2. 检测 =val= 是否小于等于 10. 若检测成功, 执行 =for= 循环体. 若失败, 退出循环,
   继续执行 =for= 循环体之后的第一条语句.
3. 将 =val= 的值增加 1.
4. 重复第 2 步的条件检测, 只要条件为真就继续执行剩余步骤.

*** 读取数量不定的输入数据

拓展上一个对 1 到 10 求和程序的一个自然的想法就是实现对用户输入的一组数求和. 在
这种情况下, 我们预先不知道要对多少个数求和, 这就需要不断读取数据直至没有新的输入
为止, 代码如下:

#+begin_src cpp
#include <iostream>
int main() {
  int sum = 0, value = 0;
  // 读取数据直到遇见文件尾, 计算所有读入的值的和
  while (std:: cin >> value)
    sum += value;
  std::cout << "Sum is: " << sum << std::endl;
  return 0;
}
#+end_src

如果我们输入:

#+begin_src
3 4 5 6
#+end_src

则程序会输出:

#+begin_src
Sum is: 18
#+end_src
这个程序使用了 =istream= 对象作为条件, 其效果是检测流的状态. 如果流是有效的, 即
流未遇到错误, 那么检测成功. 当遇到 *文件结束符* (end-of-file), 或遇到一个无效输
入时 (例如读入的值不是一个整数), =istream= 的对象的状态就会变为无效. 处于无效状
态的 =istream= 对象会使条件变为假.

\vspace*{1\baselineskip}
\begin{note}[从键盘输入文件结束符]

如何指出文件结束, 不同操作系统是不同的.

在 Windows 系统中, 输入文件结束符的方法是敲 Ctrl+Z.

在 UNIX 系统中, 包括 Mac OS X 系统中, 是用 Ctrl+D.
\end{note}


\vspace*{1\baselineskip}
\begin{note}[常见错误]

下面列出一些编译器可以检查出的错误:

1. 语法错误(syntax error): 犯了 C++ 语言文法上的错误

2. 类型错误 (type error): C++ 中每个数据项都有其类型.

3. 声明错误 (declaration error): 每个名字都要先声明, 后使用.
\end{note}

*** if 语句

与大多数语言一样, C++ 也提供了 *if 语句* 来支持条件执行. 我们可以用 =if= 语句写一
个程序, 来统计在输入中, 每个值连续出现了多少次:

#+begin_src cpp
#include <iostream>

int main() {
  // currVal 是我们正在统计的数; 我们将读入的新值存入 val
  int currVal = 0, val = 0;
  // 读取一个新数, 并确保确实有数据可以处理
  if (std::cin >> currVal) {
    int cnt = 1;                // 保存我们正在处理的当前值的个数
    while (std::cin >> val) { // 读取剩余的数
      if (val == currVal)     // 如果值相同
        ++cnt;                // 将 cnt 加 1
      else {                  // 否则, 打印前一个数的值
        std::cout << currVal << " occurs "
                  << cnt << " times" << std::endl;
        currVal = val;        // 记住新值
        cnt = 1;              // 重置计数器
      }
    }
  }
}
#+end_src

如果我们输入如下内容:

#+begin_src
42 42 42 42 42 55 55 62 100 100 100
#+end_src

则应该输出:

#+begin_src
42 occurs 5 times
55 occurs 2 times
62 occurs 1 times
#+end_src

第二条 =if= 语句使用了 *相等运算符* (~==~) 来检测 ~val~ 是否等于 ~currVal~

\vspace*{1\baselineskip}
\begin{note}
C++ 用 = 进行赋值, 用 == 作为相等运算符.
\end{note}


\vspace*{1\baselineskip}
\begin{definition}[C++ 程序的缩进和格式]
C++ 很大程度上是格式自由的, 不存在正确的格式, 但是你最好应该保持一致的风格.
\end{definition}

** 类简介

在解决书店程序之前, 我们还需要了解的唯一的一个 C++ 特性就是如何定义一个 *数据结
构* (data structure) 来表示销售数据. 在 C++ 中, 我们通过定义一个 *类* (class) 来
定义自己的数据结构.

一个类定义了一个类型, 以及与其相关联的一组操作.

类机制是 C++ 最重要的特性之一. C++ 最初的设计焦点就是能定义使用上像内置类型一样
自然的 *类类型* (type).

在这节中, 我们只介绍简单的使用类, 而不关心它的实现.

*** Sales_item 类

~Sales_item~ 类的作用是表示一本书的总销售额, 售出册数和平均售价.

每个类实际上都定义了一个新的类型, 其类型名就是类名. 因此, 我们的 ~Sales_item~ 定
义了一个名为 ~Sales_item~ 的类型. 与内置类型一样, 我们可以定义类类型的变量.

当我们写下:

#+begin_src
Sales_item item;
#+end_src

表示的是 ~item~ 是一个 ~Sales_item~ 类型的对象. 我们通常将 "一个 ~Sales_item~ 类
型的对象" 简单说成 "一个 ~Sales_item~ 对象", 或更简单 "一个 ~Sales_item~"

对于 ~Sales_item~ 这个类, 除了可以定义 ~Sales_item~ 的对象外, 还可以:

+ 调用一个名为 ~isbn~ 的函数从一个 ~Sales_item~ 对象中提取 ~ISBN~ 号.
+ 用输入运算符 (>>) 和输出运算符 (<<) 读, 写 ~Sales_item~ 对象.
+ 用加法运算符 (+) 将两个 ~Sales_item~ 对象相加. 两个对象必须是同一本书 (相同的
  ~ISBN~). 运算结果是一个新的 ~Sales_item~ 对象, ~ISBN~ 不变, 总销售额和售出册数
  则是两个运算对象的对应值之和.
+ 使用复合赋值运算符 (+=) 将一个 ~Sales_item~ 对象加到另一个对象上.

\vspace*{1\baselineskip}
\begin{definition}[类定义了行为]
你要记住的是, 类 Sales\_item 的作者定义了类对象可以执行的所有动作.

一般而言, 类的作者决定了类对象上可以使用的所有操作.
\end{definition}

**** 读写 Sales_item

如下面这个程序, 从标准输入读入数据, 存入一个 ~Sales_item~ 对象中, 然后将
~Sales_item~ 的内容写回到标准输出:

#+begin_src cpp
#include <iostream>
#include "Sales_item.h"

int main() {
  Sales_item book;
  // 读入 ISBN 号, 售出的册数以及销售价格
  std::cin >> book;
  // 写入 ISBN, 售出的册数, 总销售数和平均价格
  std::count << book << std::endl;
  return 0;
}
#+end_src

如果输入:

#+begin_src
0-201-70353-X 4 24.99
#+end_src

则输出:
#+begin_src
0-201-70353-X 4 99.96 24.99
#+end_src

此程序以两个 ~#include~ 指令开始, 其中一个使用了新的形式. 包含来自标准库的头文件,
我们用 (< >) 包围头文件名. 对于不属于标准库的头文件, 则使用 ("") 包围.

\vspace*{1\baselineskip}
\begin{note}[使用文件重定向]

反复从键盘敲入那些销售记录是乏味的. 大多数操作系统支持文件重定向.

$ addItems <infile >outfile

这样就可以从一个名为 infile 的文件中读取销售记录, 并将结果输出到一个名为 outfile 的文件.
\end{note}

*** 初始成员函数

将两个 ~Sales_item~ 对象相加的程序首先应该检查两个对象是否具有相同的 =ISBN=, 示
例如下:

#+begin_src cpp
#include <iostream>
#include "Sales_item.h"

int main ()
{
  Sales_item item1, item2;
  std::cin >> item1 >> item2;
  // 首先检查 item1 和 item2 是否表示相同的书
  if (item1.isbn() == item2.isbn()) {
    std::cout << item1 + item2 << std::endl;
    return 0;    // 表示成功
  } else {
    std::cerr << "Data must refer to same ISBN"
              << std::endl;
    return -1;   // 表示失败
  }
}
#+end_src

**** 什么是成员函数

上面例子中的 ~if~ 语句的检测条件

#+begin_src
item1.isbn() == item2.isbn()
#+end_src

调用名为 ~isbn~ 的 *成员函数* (member function). 成员函数时定义为类的一部分的函数,
有时也称为 *方法* (method).

我们使用 *点运算符* (.) 来表达我们需要 "名为 ~item1~ 的对象的 ~isbn~ 成员". 点运
算符只能用于类类型的对象.

我们使用 *调用运算符* (()) 来调用一个函数. 圆括号里面放置 *实参* (argument) 列表
(可能为空). 成员函数 ~isbn~ 不接受任何参数.

这个函数返回的是保存在 ~item1~ 中的 =ISBN= 书号.

** 书店程序

现在我们已经准备好完成书店程序了. 我们需要从一个文件中读取销售记录, 生成每本书的
销售报告. 我们假定每个 ISBN 号的所有销售记录在文件中是聚
在一起保存的.

我们的程序会将每个 =ISBN= 的所有数据合并起来, 存入名为 ~total~ 的变量中. 我们使用
另一个名为 ~trans~ 的变量保存读取的每条销售记录. 如果 ~trans~ 和 ~total~ 指向相
同的 =ISBN=, 我们会更新 ~total~ 的值. 否则, 我们会打印 ~total~ 的值, 并将其重置
为刚刚读取的数据 (~trans~).

代码如下:

#+begin_src cpp
#include <iostream>
#include "Sales_item.h"

int main()
{
  Sales_item total; // 保存和的变量
  // 读入第一条交易记录, 并确保有数据可以处理
  if (std::cin >> total) {
    Sales_item trans;   // 保存下一条交易记录的变量
    // 读入并处理剩余交易记录
    while (std::cin >> trans) {
      // 如果我们仍在处理相同的书
      if (total.isbn() == trans.isbn())
        total += trans; // 更新总销售额
      else {
        // 打印前一本书的结果
        std::cout << total << std::endl;
        total = trans;  // total 现在表示下一本书的销售额
      }
    }
    std::cout << total << std::endl; // 打印最后一本书的结果
  } else {
    // 警告读者没有输入
    std::cerr << "No data?!" << std::endl;
    return -1;
  }
  return 0;
}
#+end_src


* 变量和基本类型

\begin{introduction}
  \item 基本内置类型
  \item 变量
  \item 复合类型
  \item const 限定符
  \item 处理类型
  \item 自定义数据结构
\end{introduction}


数据类型是程序的基础: 它高速我们数据的意义以及我们能在数据上执行的操作.

** 基本内置类型

C++ 定义了一套包括 *算数类型* (arithmetic type) 和 *空类型* (void) 在内的基本数
据类型.

*** 算数类型

算数类型分为两类: *整型* (integral type, 包括字符和布尔类型在内) 和 *浮点型*.

算数类型的尺寸 (也就是该类型数据所占的比特数) 在不同机器上有所差别. 下表列出了
C++ 标准规定的尺寸的最小值, 同时允许编译器赋予这些类型更大的尺寸.

#+NAME: C++: 算数类型
| 类型        | 含义         | 最小尺寸      |
|-------------+--------------+---------------|
| ~bool~      | 布尔类型     | 未定义        |
| ~char~      | 字符         | 8 位          |
| ~wchar_t~   | 宽字符       | 16 位         |
| ~char16_t~  | Unicode 字符 | 16 位         |
| ~char32_t~  | Unicode 字符 | 32 位         |
| ~short~     | 短整型       | 16 位         |
| ~int~       | 整型         | 16 位         |
| ~long~      | 长整型       | 32 位         |
| ~long long~ | 长整型       | 64 位         |
| ~float~     | 单精度浮点数 | 6 位有效数字  |
| ~double~    | 双精度浮点数 | 10 位有效数字 |
| long double | 拓展精度浮点 | 10 位有效数字 |

基本的字符类型是 ~char~, 一个 ~char~ 的空间应确保可以存放机器基本字符集中任意字
符对应的数字值. 也就是说, 一个 ~char~ 的大小和一个机器字节一样.

其他字符类型用于拓展字符集, char16_t 和 char32_t 是为 =Unicode= 字符集服务.

**** 带符号类型和无符号类型

除去布尔型和拓展的字符型之外, 其他整型可以划分为 *带符号的* (signed) 和 *无符号
的* (unsigned) 两种. 带符号的可以表示正数, 负数或 0, 无符号类型仅能表示大于等于
0 的值.

类型 ~int~, ~short~, ~long~ 和 ~long long~ 都是带符号的, 通过在这些类型名之前加
上 ~unsigned~ 就可以得到无符号类型.

与其他整型不同, 字符型被被分为了三种: ~char~, ~signed char~ 和 ~unsigned char~.

无符号类型中所有比特都用来存储值, 例如, 8 比特的 ~unsigned char~ 可以表示 0 至
255 区间内的值.

C++ 标准并没有规定带符号类型应如何表示, 但是约定了在表示范围内的正值和负值应该平
均. 因此, 8 比特的 ~signed char~ 理论上应该可以表示 -127 至 127 区间内的值. 大多
数现代计算机将实际的表示范围定为 -128 至 127.

\begin{definition}[如何选择类型]

\end{definition}
