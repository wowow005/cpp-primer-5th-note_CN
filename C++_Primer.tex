% Created 2022-05-03 Tue 09:54
% Intended LaTeX compiler: xelatex
\documentclass[lang=cn]{elegantbook}
                 \usepackage{minted}
                 \usepackage{xeCJK}
\setCJKmainfont{LXGW WenKai}
\documentclass[pad]{elegantbook}
\documentclass[hang]{elegantbook}
\author{Mushi}
\date{\textit{[2022-04-30 Sat 16:27]}}
\title{C++ Primer Note}
\hypersetup{
 pdfauthor={Mushi},
 pdftitle={C++ Primer Note},
 pdfkeywords={},
 pdfsubject={},
 pdfcreator={Emacs 27.2 (Org mode 9.6)}, 
 pdflang={English}}
\begin{document}

\maketitle
\tableofcontents



\mainmatter

\chapter{开始}
\label{sec:org748ad1f}

\begin{introduction}
  \item 一个简单的 C++ 程序
  \item 输入输出
  \item 注释简介
  \item 控制流
  \item 类简介
  \item 书店程序
\end{introduction}

\section{编写一个简单的 C++ 程序}
\label{sec:org615edee}

每个 C++ 程序都包含一个或多个 \textbf{函数} (function), 其中一个必须命名为 \texttt{main}. 操作系统
通过调用 \texttt{main} 来运行 C++ 程序.

\vspace*{1\baselineskip}

示例如下所示:

\begin{minted}[]{cpp}
int main() {
  return 0;
}
\end{minted}

一个函数的定义包含四部分: \textbf{返回类型} (return type), \textbf{函数名} (function), 一个括
号包围的 \textbf{形参列表} (parameter list, 允许为空) 以及 \textbf{函数体} (function body)

\texttt{main} 函数的返回类型必须是 \texttt{int}, 即整数类型. \texttt{int} 类型是一种 \textbf{内置类型}
(built-in-type), 即语言自身定义的类型.

这个语句中唯一的一条语句是 \texttt{return}, 它结束函数的执行. 在本例中, \texttt{return} 还会向
调用者返回一个值. 当 \texttt{return} 语句包括一个值时, 次返回的类型必须与函数的返回类型
相容.

\vspace*{1\baselineskip}

\begin{note}
在 C/C++ 中, 新手常犯的错误就是忘记写分号. 代码写多了形成条件反射了就好了(当然有时候还是会漏掉 LOL).
\end{note}

\vspace*{1\baselineskip}

在大多数系统中, \texttt{main} 的返回值被用来指示状态. 返回值 \texttt{0} 表示成功. 非 \texttt{0} 返回
值由系统定义, 通常用来指出错误类型.

\vspace*{1\baselineskip}

\begin{definition}[类型]
类型是程序设计中最基本的概念之一, 在本书中我们会反复遇到他. 一种类型不仅定义了数据元素的内容, 还定义了这类数据上可以进行的运算.

程序所处理的数据都保存在变量中, 而每个变量都有自己的类型.
\end{definition}

\subsection{编译, 运行程序}
\label{sec:orgd46695c}

如何编译程序依赖于你使用的操作系统和编译器. 这里我不想展开讨论, 你可以通过搜索引
擎解决这些问题. 你的搜索关键词应该是 ``<你的操作系统> + 搭建 C++ 运行环境''

尽管在生产环境中使用 \textbf{集成开发环境} (Integrated Developed Enveloped Environment,
IDE) 是高效的. 但我个人还是推荐你先借助命令行界面学习 C++ 本身, 一旦你掌握了语言,
IDE 再强大也只是一个工具而已.

\begin{enumerate}
\item 程序源文件
\label{sec:orga07500f}

大多数编译器都要求程序源码存储在一个或多个文件中. 程序文件通常被称为 \texttt{源文件}
(source file).

不同编译器使用不同的后缀命名方式, 最常见的包括 \texttt{.cc}, \texttt{.cxx}, \texttt{.cpp}, \texttt{.cp} 及 \texttt{.c}

\item 从命令行运行编译器
\label{sec:orga761210}

这里我简单演示一下命令行编译过程, 见下图:

\begin{center}
\includegraphics[width=1.0\textwidth]{img/democc_演示.png}
\end{center}

\begin{note}
这里的 echo \$? 是一个 UNIX 命令, 它这里返回的就是最近的函数返回值. 在 Windows 系统中, 可以键入 echo \%ERRORLEVEL\% 查看
\end{note}
\end{enumerate}

\section{初始输入输出}
\label{sec:orgfc7f62f}

C++ 语言并未定义任何输入输出 (IO) 语句, 取而代之, 包含了一个全面的 \textbf{标准库}
(standard library) 来提供 IO 机制 (以及很多其他设施).

\textbf{iostream} 库包含两个基本类型 \textbf{istream} 和 \textbf{ostream}, 分别表示输入流和输出流. 一
个流就是一个字符序列. 术语 (stream) 想要表达的是, 随着时间的推移, 字符是顺序生
成或消耗的.

\subsection{标准输入输出对象}
\label{sec:orge7886fc}

标准库定义了 4 个 IO 对象, 见下表:

\begin{table}[htbp]
\label{4 个 IO 对象}
\centering
\begin{tabular}{llll}
对象名 & 作用 & 别称 & 所属类\\
\hline
\texttt{cin} & 处理输入 & 标准输入 (standard input) & \texttt{istream}\\
\texttt{cout} & 处理输出 & 标准输出 (standard output) & \texttt{ostream}\\
\texttt{cerr} & 输出警告和错误消息 & 标准错误 (standard error) & \texttt{ostream}\\
\texttt{clog} & 输出程序运行时的一般性信息 & 无 & \texttt{ostream}\\
\end{tabular}
\end{table}

系统通常将程序所运行的窗口与这些对象关联起来. 因此, 当我们读取 \texttt{cin}, 数据将从程
序正在运行的窗口读入, 当我们向 \texttt{cout}, \texttt{cerr}, 和 \texttt{clog} 写入数据时, 将会写到同
一个窗口.

\subsection{一个使用 IO 库的程序}
\label{sec:org190748c}

在书店程序中, 我们需要将多条记录合并成单一的汇总表. 作为一个相关的, 但更简单的问
题, 我们先看一下如何将两个数相加. 通过使用 IO 库, 我们可以拓展 \texttt{main} 程序, 使之
能提示用户输入两个数, 然后输出它们的和:

\begin{minted}[]{cpp}
#include <iostream>

int main() {
  std::cout << "Enter two numbers:" << std::endl;
  int v1 = 0, v2 = 0;
  std::cin >> v1 >> v2;
  std::cout << "The sum of " << v1 << " and " << v2
            << " is " << v1 + v2 << std::endl;
  return 0;
}
\end{minted}

尖括号中的 \texttt{iostream} 指出了一个 \texttt{头文件} (header). 我们一般一个程序的所有
\texttt{\#include} 指令都放在源文件的开始位置.

\subsection{向流写入数据}
\label{sec:org36f6c7a}

\texttt{main} 函数体的第一条语句执行了一个 \textbf{表达式} (expression). 在 C++ 中, 一个表达式
产生一个计算结果, 它由一个或多个运算对象和 (通常是) 一个运算符组成.

这条语句使用了 \textbf{输出运算符} (\texttt{<<}) 在标准输出上打印消息:

\begin{minted}[]{cpp}
std::cout << "Enter two numbers:" << std::endl;
\end{minted}

\texttt{<<} 运算符接受两个运算对象: 左侧的运算对象必须是一个 \texttt{ostream} 对象, 右侧的运算
对象是要打印的值. 此运算符将给定的值写到给定的 \texttt{ostream} 对象中. 计算结果是我们
写入给定值的那个 \texttt{ostream} 对象.

我们的输出语句使用了两次 << 运算符. 我们的表达式等价于:

\begin{minted}[]{cpp}
(std::cout << "Enter two numbers:") << std::endl;
\end{minted}

我们也可以把它变成两条语句, 效果是一样的:

\begin{minted}[]{cpp}
std::cout << "Enter two numbers:";
std::cout << std::endl;
\end{minted}

第一个输出运算符给用户打印一条消息. 这个消息是一个 \textbf{字符串字面值常量} (string
literal).

第二个运算符打印 \texttt{endl}, 这是一个被称为 \textbf{操纵符} 的特殊值. 写入 \texttt{endl} 的效果是
结束当前行, 并将与设备关联的 \textbf{缓冲区} (buffer) 中的内容刷到设备中.

\vspace*{1\baselineskip}
\begin{note}
程序员常常在调试时添加打印语句. 这类语句应该保证 "一直" 刷新流. 否则, 如果程序崩溃, 输出可能还留在缓冲区中, 从而导致关于程序崩溃的错误推断.
\end{note}

\subsection{使用标准库中的名字}
\label{sec:orgd03c6d8}

前缀 \texttt{std::} 指出名字 \texttt{cout} 和 \texttt{endl} 是定义在名为 \textbf{std} 的命名空间 (namespace)
中的. 命名空间可以避免名字定义的冲突, 标准库定义的名字都在命名空间 \texttt{std} 中.

当我们使用标准库中的一个名字时, 必须显示说明我们想使用来自命名空间 \texttt{std} 中的名
字. 例如, 需要写出 \texttt{std::cout}, 通过使用 \textbf{作用域运算符} (\texttt{::}) 来指出我们想使用
定义在命名空间 \texttt{std} 中的名字 \texttt{cout}. 后面我们会介绍一种更简单的访问命名空间的方
法.

\subsection{从流读取数据}
\label{sec:org8651fa9}

\begin{minted}[]{cpp}
int v1 = 0, v2 = 0;
\end{minted}

我们将这两个变量定义为 \texttt{int} 类型, \texttt{int} 是一种内置类型, 用来表示整数. 还将它们
\textbf{初始化} (initialize) 为 0. 初始化一个变量, 就是在变量创建的同时为它赋予一个值.

下一条语句是

std::cin >> v1 >> v2;

\textbf{输入运算符} (\texttt{>>}) 与输出运算符相似

\subsection{完成程序}
\label{sec:org78bb4cc}

剩下的就是打印计算结果了:

\begin{minted}[]{cpp}
std::cout << "The sum of " << v1 << " and " << v2
          << " is " << v1 + v2 << std::endl;
\end{minted}

可以发现, 这里的运算对象并不都是相同类型的值. 某些运算对象是字符串字面值常量, 某
些是 \texttt{int} 值.

标准库定义了不同版本的输入输出运算符, 来处理这些不同类型的运算对象.

\section{注释简介}
\label{sec:orgc9def65}

注释可以帮助人类读者理解程序.

\subsection{C++ 中的两种注释}
\label{sec:org5cb42e9}

\begin{minted}[]{cpp}
// 双斜线注释常用于半行和单行附注.

/* 注释界定符
   通常用于
   多行注释
*/
\end{minted}

\subsection{注释界定符不能嵌套}
\label{sec:orgd0982af}

界定注释符不能嵌套使用, 如果你这么做了, 编译器会产生错误.

最好的方式是用双斜线注释掉代码段的每一行.

\begin{minted}[]{cpp}
// /*
// * 单行注释中的任何内容都会被忽略
// * 包括嵌套的注释对也一样会被忽略
// */
\end{minted}

\section{控制流}
\label{sec:orgf215cd0}

语句一般是顺序执行的, 但程序设计语言提供了多种不同的控制流语句, 允许我们写出更为
复杂的执行路径.

\subsection{while 语句}
\label{sec:org7bcaaa8}

\textbf{while语句} 反复执行一段代码, 直到给定条件为假为止. 我们可以用 \texttt{while} 语句编写
一段程序, 求 1 到 10 这 10 个数的之和:

\begin{minted}[]{cpp}
#include <iostream>
int main() {
  int sum = 0, val = 1;
  // 只要 val 的值小于等于 10, while 循环就会持续执行
  while (val <= 10) {
    sum += val; // 将 sum + val 赋予 sum
    ++val;      // 将 val 加 1
  }
  std::cout << "sum of 1 to 10 inclusive is "
            << sum << std::endl;
  return 0;
}
\end{minted}

我们编译这个程序, 它会打印出:

\begin{verbatim}
sum of 1 to 10 inclusive is 55
\end{verbatim}


\texttt{while} 语句的形式为:

\begin{minted}[]{cpp}
while (condition)
  statement
\end{minted}

\texttt{while} 语句的执行过程就是交替地监测 condition 条件和执行关联的语句 statement,
直至 consition 为假时停止. 所谓 \textbf{条件} (condition) 就是一个产生真或假的结果的表
达式.

条件中使用了 \textbf{小于等于运算符} (<=) 运算符来比较 val 的当前值和 10.

循环体是由两条语句组成的语句块.

\begin{minted}[]{cpp}
{
    sum += val; // 将 sum + val 赋予 sum
    ++val;      // 将 val 加 1
}
\end{minted}

所谓 \textbf{语句块} (block) 就是用花括号包围的零条或多条语句的序列. 语句块也是语句的一
种, 在任何要求使用语句的地方都可以使用语句块.

上面的语句块的第一条语句使用了 \textbf{复合赋值运算符} (+=). 此运算符将其右侧的运算对象
加到左侧运算对象中. 它本质上与一个加法结合一个 \textbf{赋值} (assignment) 是相同的.

第二条语句使用 \textbf{前缀递增运算符} (++). 递增运算符将运算对象的值增加 1. \texttt{++val} 等
价于 \texttt{val=val+1}.

\subsection{for 语句}
\label{sec:orged06265}

在 \texttt{while} 语句中, 使用变量 \texttt{val} 来控制循环执行的次数. 在循环条件中监测 \texttt{val} 的
值, 在 \texttt{while} 循环体中将 \texttt{val} 递增.

这种在循环条件中检测变量, 在循环体中递增变量的模式使用非常频繁, 以至于 C++ 语言
专门定义了第二种循环语句, \textbf{for 语句}, 来简化复合这种模式的语句. 可以用 \texttt{for} 语
句来重写从 1 加到 10 的程序:

\begin{minted}[]{cpp}
#include <iostream>
int main() {
  int sum = 0;
  // 从 1 加到 10
  for (int val = 1; val <= 10; ++val) {
    sum +=val;
  }
  std::cout << "Sum of 1 to 10 inclusive is "
            << sum << std::endl;
  return 0;
}
\end{minted}

每个 \texttt{for} 语句都包含两部分: 循环头和循环体. 循环头控制循环体的执行次数, 它由三
部分组成:

\begin{itemize}
\item 初始化语句 (init-statement)
\item 循环条件 (condition)
\item 表达式 (expression)
\end{itemize}

在本例中, 初始化语句为:

\begin{minted}[]{cpp}
int val = 1
\end{minted}

它定义了一个名为 \texttt{val} 的 \texttt{int} 型对象, 并为其赋值为 1. 变量 \texttt{val} 仅在 \texttt{for} 循
环内部存在, 在循环结束之后是不能使用的. 循环条件:

\begin{minted}[]{cpp}
val <= 10
\end{minted}

循环体每次执行前都会先检查循环条件.

表达式在 \texttt{for} 循环体之后执行. 在本例中表达式:

\begin{minted}[]{cpp}
++val
\end{minted}

简要重述一下 \texttt{for} 循环的总体执行过程:

\begin{enumerate}
\item 创建变量 \texttt{val}, 将其初始化为 1.
\item 检测 \texttt{val} 是否小于等于 10. 若检测成功, 执行 \texttt{for} 循环体. 若失败, 退出循环,
继续执行 \texttt{for} 循环体之后的第一条语句.
\item 将 \texttt{val} 的值增加 1.
\item 重复第 2 步的条件检测, 只要条件为真就继续执行剩余步骤.
\end{enumerate}

\subsection{读取数量不定的输入数据}
\label{sec:orgaa4ce68}

拓展上一个对 1 到 10 求和程序的一个自然的想法就是实现对用户输入的一组数求和. 在
这种情况下, 我们预先不知道要对多少个数求和, 这就需要不断读取数据直至没有新的输入
为止, 代码如下:

\begin{minted}[]{cpp}
#include <iostream>
int main() {
  int sum = 0, value = 0;
  // 读取数据直到遇见文件尾, 计算所有读入的值的和
  while (std:: cin >> value)
    sum += value;
  std::cout << "Sum is: " << sum << std::endl;
  return 0;
}
\end{minted}

如果我们输入:

\begin{verbatim}
3 4 5 6
\end{verbatim}

则程序会输出:

\begin{verbatim}
Sum is: 18
\end{verbatim}
这个程序使用了 \texttt{istream} 对象作为条件, 其效果是检测流的状态. 如果流是有效的, 即
流未遇到错误, 那么检测成功. 当遇到 \textbf{文件结束符} (end-of-file), 或遇到一个无效输
入时 (例如读入的值不是一个整数), \texttt{istream} 的对象的状态就会变为无效. 处于无效状
态的 \texttt{istream} 对象会使条件变为假.

\vspace*{1\baselineskip}
\begin{note}[从键盘输入文件结束符]

如何指出文件结束, 不同操作系统是不同的.

在 Windows 系统中, 输入文件结束符的方法是敲 Ctrl+Z.

在 UNIX 系统中, 包括 Mac OS X 系统中, 是用 Ctrl+D.
\end{note}


\vspace*{1\baselineskip}
\begin{note}[常见错误]

下面列出一些编译器可以检查出的错误:

1. 语法错误(syntax error): 犯了 C++ 语言文法上的错误

2. 类型错误 (type error): C++ 中每个数据项都有其类型.

3. 声明错误 (declaration error): 每个名字都要先声明, 后使用.
\end{note}

\subsection{if 语句}
\label{sec:org4122186}

与大多数语言一样, C++ 也提供了 \textbf{if 语句} 来支持条件执行. 我们可以用 \texttt{if} 语句写一
个程序, 来统计在输入中, 每个值连续出现了多少次:

\begin{minted}[]{cpp}
#include <iostream>

int main() {
  // currVal 是我们正在统计的数; 我们将读入的新值存入 val
  int currVal = 0, val = 0;
  // 读取一个新数, 并确保确实有数据可以处理
  if (std::cin >> currVal) {
    int cnt = 1;                // 保存我们正在处理的当前值的个数
    while (std::cin >> val) { // 读取剩余的数
      if (val == currVal)     // 如果值相同
        ++cnt;                // 将 cnt 加 1
      else {                  // 否则, 打印前一个数的值
        std::cout << currVal << " occurs "
                  << cnt << " times" << std::endl;
        currVal = val;        // 记住新值
        cnt = 1;              // 重置计数器
      }
    }
  }
}
\end{minted}

如果我们输入如下内容:

\begin{verbatim}
42 42 42 42 42 55 55 62 100 100 100
\end{verbatim}

则应该输出:

\begin{verbatim}
42 occurs 5 times
55 occurs 2 times
62 occurs 1 times
\end{verbatim}

第二条 \texttt{if} 语句使用了 \textbf{相等运算符} (\texttt{==}) 来检测 \texttt{val} 是否等于 \texttt{currVal}

\vspace*{1\baselineskip}
\begin{note}
C++ 用 = 进行赋值, 用 == 作为相等运算符.
\end{note}


\vspace*{1\baselineskip}
\begin{definition}[C++ 程序的缩进和格式]
C++ 很大程度上是格式自由的, 不存在正确的格式, 但是你最好应该保持一致的风格.
\end{definition}

\section{类简介}
\label{sec:org5a50424}

在解决书店程序之前, 我们还需要了解的唯一的一个 C++ 特性就是如何定义一个 \textbf{数据结
构} (data structure) 来表示销售数据. 在 C++ 中, 我们通过定义一个 \textbf{类} (class) 来
定义自己的数据结构.

一个类定义了一个类型, 以及与其相关联的一组操作.

类机制是 C++ 最重要的特性之一. C++ 最初的设计焦点就是能定义使用上像内置类型一样
自然的 \textbf{类类型} (type).

在这节中, 我们只介绍简单的使用类, 而不关心它的实现.

\subsection{Sales\_item 类}
\label{sec:org2472844}

\texttt{Sales\_item} 类的作用是表示一本书的总销售额, 售出册数和平均售价.

每个类实际上都定义了一个新的类型, 其类型名就是类名. 因此, 我们的 \texttt{Sales\_item} 定
义了一个名为 \texttt{Sales\_item} 的类型. 与内置类型一样, 我们可以定义类类型的变量.

当我们写下:

\begin{verbatim}
Sales_item item;
\end{verbatim}

表示的是 \texttt{item} 是一个 \texttt{Sales\_item} 类型的对象. 我们通常将 ``一个 \texttt{Sales\_item} 类
型的对象'' 简单说成 ``一个 \texttt{Sales\_item} 对象'', 或更简单 ``一个 \texttt{Sales\_item}''

对于 \texttt{Sales\_item} 这个类, 除了可以定义 \texttt{Sales\_item} 的对象外, 还可以:

\begin{itemize}
\item 调用一个名为 \texttt{isbn} 的函数从一个 \texttt{Sales\_item} 对象中提取 \texttt{ISBN} 号.
\item 用输入运算符 (>>) 和输出运算符 (<<) 读, 写 \texttt{Sales\_item} 对象.
\item 用加法运算符 (+) 将两个 \texttt{Sales\_item} 对象相加. 两个对象必须是同一本书 (相同的
\texttt{ISBN}). 运算结果是一个新的 \texttt{Sales\_item} 对象, \texttt{ISBN} 不变, 总销售额和售出册数
则是两个运算对象的对应值之和.
\item 使用复合赋值运算符 (+=) 将一个 \texttt{Sales\_item} 对象加到另一个对象上.
\end{itemize}

\vspace*{1\baselineskip}
\begin{definition}[类定义了行为]
你要记住的是, 类 Sales\_item 的作者定义了类对象可以执行的所有动作.

一般而言, 类的作者决定了类对象上可以使用的所有操作.
\end{definition}

\begin{enumerate}
\item 读写 Sales\_item
\label{sec:org48240f7}

如下面这个程序, 从标准输入读入数据, 存入一个 \texttt{Sales\_item} 对象中, 然后将
\texttt{Sales\_item} 的内容写回到标准输出:

\begin{minted}[]{cpp}
#include <iostream>
#include "Sales_item.h"

int main() {
  Sales_item book;
  // 读入 ISBN 号, 售出的册数以及销售价格
  std::cin >> book;
  // 写入 ISBN, 售出的册数, 总销售数和平均价格
  std::count << book << std::endl;
  return 0;
}
\end{minted}

如果输入:

\begin{verbatim}
0-201-70353-X 4 24.99
\end{verbatim}

则输出:
\begin{verbatim}
0-201-70353-X 4 99.96 24.99
\end{verbatim}

此程序以两个 \texttt{\#include} 指令开始, 其中一个使用了新的形式. 包含来自标准库的头文件,
我们用 (< >) 包围头文件名. 对于不属于标准库的头文件, 则使用 (``'') 包围.

\vspace*{1\baselineskip}
\begin{note}[使用文件重定向]

反复从键盘敲入那些销售记录是乏味的. 大多数操作系统支持文件重定向.

$ addItems <infile >outfile

这样就可以从一个名为 infile 的文件中读取销售记录, 并将结果输出到一个名为 outfile 的文件.
\end{note}
\end{enumerate}

\subsection{初始成员函数}
\label{sec:orgf15346f}

将两个 \texttt{Sales\_item} 对象相加的程序首先应该检查两个对象是否具有相同的 \texttt{ISBN}, 示
例如下:

\begin{minted}[]{cpp}
#include <iostream>
#include "Sales_item.h"

int main ()
{
  Sales_item item1, item2;
  std::cin >> item1 >> item2;
  // 首先检查 item1 和 item2 是否表示相同的书
  if (item1.isbn() == item2.isbn()) {
    std::cout << item1 + item2 << std::endl;
    return 0;    // 表示成功
  } else {
    std::cerr << "Data must refer to same ISBN"
              << std::endl;
    return -1;   // 表示失败
  }
}
\end{minted}

\begin{enumerate}
\item 什么是成员函数
\label{sec:orga04ce98}

上面例子中的 \texttt{if} 语句的检测条件

\begin{verbatim}
item1.isbn() == item2.isbn()
\end{verbatim}

调用名为 \texttt{isbn} 的 \textbf{成员函数} (member function). 成员函数时定义为类的一部分的函数,
有时也称为 \textbf{方法} (method).

我们使用 \textbf{点运算符} (.) 来表达我们需要 ``名为 \texttt{item1} 的对象的 \texttt{isbn} 成员''. 点运
算符只能用于类类型的对象.

我们使用 \textbf{调用运算符} (()) 来调用一个函数. 圆括号里面放置 \textbf{实参} (argument) 列表
(可能为空). 成员函数 \texttt{isbn} 不接受任何参数.

这个函数返回的是保存在 \texttt{item1} 中的 \texttt{ISBN} 书号.
\end{enumerate}

\section{书店程序}
\label{sec:org3c5ac29}

现在我们已经准备好完成书店程序了. 我们需要从一个文件中读取销售记录, 生成每本书的
销售报告. 我们假定每个 ISBN 号的所有销售记录在文件中是聚
在一起保存的.

我们的程序会将每个 \texttt{ISBN} 的所有数据合并起来, 存入名为 \texttt{total} 的变量中. 我们使用
另一个名为 \texttt{trans} 的变量保存读取的每条销售记录. 如果 \texttt{trans} 和 \texttt{total} 指向相
同的 \texttt{ISBN}, 我们会更新 \texttt{total} 的值. 否则, 我们会打印 \texttt{total} 的值, 并将其重置
为刚刚读取的数据 (\texttt{trans}).

代码如下:

\begin{minted}[]{cpp}
#include <iostream>
#include "Sales_item.h"

int main()
{
  Sales_item total; // 保存和的变量
  // 读入第一条交易记录, 并确保有数据可以处理
  if (std::cin >> total) {
    Sales_item trans;   // 保存下一条交易记录的变量
    // 读入并处理剩余交易记录
    while (std::cin >> trans) {
      // 如果我们仍在处理相同的书
      if (total.isbn() == trans.isbn())
        total += trans; // 更新总销售额
      else {
        // 打印前一本书的结果
        std::cout << total << std::endl;
        total = trans;  // total 现在表示下一本书的销售额
      }
    }
    std::cout << total << std::endl; // 打印最后一本书的结果
  } else {
    // 警告读者没有输入
    std::cerr << "No data?!" << std::endl;
    return -1;
  }
  return 0;
}
\end{minted}


\chapter{变量和基本类型}
\label{sec:org90a8957}

\begin{introduction}
  \item 基本内置类型
  \item 变量
  \item 复合类型
  \item const 限定符
  \item 处理类型
  \item 自定义数据结构
\end{introduction}


数据类型是程序的基础: 它高速我们数据的意义以及我们能在数据上执行的操作.

\section{基本内置类型}
\label{sec:org9471bdc}

C++ 定义了一套包括 \textbf{算数类型} (arithmetic type) 和 \textbf{空类型} (void) 在内的基本数
据类型.

\subsection{算数类型}
\label{sec:orgd72e142}

算数类型分为两类: \textbf{整型} (integral type, 包括字符和布尔类型在内) 和 \textbf{浮点型}.

算数类型的尺寸 (也就是该类型数据所占的比特数) 在不同机器上有所差别. 下表累出了
C++ 标准规定的尺寸的最小值, 同时允许编译器赋予这些类型更大的尺寸.

\begin{table}[htbp]
\label{C++: 算数类型}
\centering
\begin{tabular}{lll}
类型 & 含义 & 最小尺寸\\
\texttt{bool} & 布尔类型 & 未定义\\
\texttt{char} & 字符 & 8 位\\
\texttt{wchar\_t} & 宽字符 & 16 位\\
\texttt{char16\_t} & Unicode 字符 & 16 位\\
\texttt{char32\_t} & Unicode 字符 & 32 位\\
\texttt{short} & 短整型 & 16 位\\
\texttt{int} & 整型 & 16 位\\
\texttt{long} & 长整型 & 32 位\\
\texttt{long long} & 长整型 & 64 位\\
\texttt{float} & 单精度浮点数 & 6 位有效数字\\
\texttt{double} & 双精度浮点数 & 10 位有效数字\\
long double & 拓展精度浮点 & 10 位有效数字\\
\end{tabular}
\end{table}
\end{document}
